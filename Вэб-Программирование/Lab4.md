# Вопросы с se.ifmo.ru

## 2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

_Inversion of Control_: объекты создает не программист (используя `new`), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к управляемым
(в Spring это классы с аннотациями `@Component`, `@Service` и т.д., в EJB — бобы `@Stateless`, `@Stateful`, `@MessageDriven`).

Контейнер не только создает объекты, но полностью управляет их жизненным циклом, вызывая на определенных этапах callback методы.

_Dependency injection_:

Вместо построения зависимостей в компоненте, где они нужны:

```java
public class Something {
  private Dependency dependency = new Dependency()
}
```

Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:

```java
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
}  
```

Чтобы нам не пришлость вручную собирать все зависимости для создания компонентов,
контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:

```java
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}
```

## 5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.

EJB (Enterprise Java Bean) — спецификация для разработки серверных компонентов, реализующих бизнес-логику.

Компоненты — бобы, которые делятся на _session beans_ (заседательные бобы) и _message driven beans_ (бобы, движимые посланиями).

_Session beans_ в свою очередь делятся на:
* _stateful_: у каждого клиента своя инстанция, в которой хранится его состояние
* _stateless_: одна и та же инстанция обеспечивает запросы нескольких клиентов => лучше масштабируются, но не могут сохранять состояние между последовательными обращениями клиента
* _singleton_: одна инстанция на все приложение => общее для всех клиентов состояние

_Message driven beans_ выполняют метод в ответ на получение сообщения из определенной очереди JMS.

Аннотация `@EJB` предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

## 7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.

Java Message Service — стандарт для асинхронного распределенного взаимодействия программных компонентов (которые могут находиться на одном компьютере, в одной локальной сети, или быть связаны через Интернет) путем рассылки сообщений.

JMS поддерживает две модели коммуникации: _point-to-point_ и _publish-subcribe (pubsub)_.

В _point-to-point_ сообщения от разных отправителей адресуются определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.

В _pubsub_ сообщения адресуются определенному topic'у, на которые подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.

Существует несколько реализаций JMS провайдеров (RabbitMQ, Open Message Queue, ...)

## 8. Понятие транзакции. Управление транзакциями в Java EE. JTA.

Транзакция — группа последовательных операций, представляет собой логическую единицу работы с данными. Транзация либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.

_Java Transaction API_ позволяет выполнять распределенные транзакции, т.е. транзакции, читающие и обновляющие данные на разных сетевых ресурсах (которыми могут быть различные серверы баз данных, JMS).

JTA предоставляет высокоуровневый интерфейс для управления транзакиями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).

Транзация координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Транзакции могут быть объявлены:
* декларативно — аннотацией `@Transactional` на отдельном методе или всем классе, при этом rollback происходит при необработанном `RuntimeException`
* программно — вызывая `begin`, `rollback`, `commit` у [`UserTransaction`](https://docs.oracle.com/javaee/6/api/javax/transaction/UserTransaction.html)
