# Лабораторная работа №1

1. Создать одномерный массив a типа short. Заполнить его чётными числами от 7 до 19 включительно в порядке убывания.
2. Создать одномерный массив x типа float. Заполнить его 18-ю случайными числами в диапазоне от -11.0 до 11.0.
3. Создать двумерный массив b размером 7x18. Вычислить его элементы по следующей формуле (где x = x[j]):
        если a[i] = 18, то b[i][j] = arcsin⁡(0.25*sin⁡(x))
        если a[i] ∈ {7, 9, 15}, то b[i][j]=sin〖((1-tan⁡(x))/2)〗^(cos⁡(x))
        для остальных значений a[i]: b[i][j]=sin⁡(arcsin⁡(1/e^(〖sin 〗^2 (tan⁡(x))) )
	      Напечатать полученный в результате массив в формате с четырьмя знаками после запятой.

# Лабораторная работа №2

На основе базового класса Pokemon написать свои классы для заданных видов покемонов. Каждый вид покемона должен иметь один или два типа и стандартные базовые характеристики:
* очки здоровья (HP)
* атака (attack)
* защита (defense)
* специальная атака (special attack)
* специальная защита (special defense)
* скорость (speed)  

Классы покемонов должны наследоваться в соответствии с цепочкой эволюции покемонов. На основе базовых классов PhysicalMove, SpecialMove и StatusMove реализовать свои классы для заданных видов атак.  

Атака должна иметь стандартные тип, силу (power) и точность (accuracy). Должны быть реализованы стандартные эффекты атаки. Назначить каждому виду покемонов атаки в соответствии с вариантом. Уровень покемона выбирается минимально необходимым для всех реализованных атак.  
Используя класс симуляции боя Battle, создать 2 команды покемонов (каждый покемон должен иметь имя) и запустить бой.

![image](https://user-images.githubusercontent.com/30019001/156451194-24b0630c-f8d7-45d1-bccf-0460ef90a4e7.png)


# Лабораторная работа №3

Разработать модель согласно предметной области:  

*Малыш подошел к ней, чмокнул ее полную руку и сказал: Затем Малыш пошел к себе в комнату и стал ждать Карлсона. Они должны были сегодня вместе отправиться на крышу, и, если бы Карлсон был только выдумкой, как уверяет Кристер, вряд ли Малыш смог бы туда попасть.*

Программа должна удовлетворять следующим требованиям:
* Доработанная модель должна соответствовать принципам SOLID.
* Программа должна содержать как минимум два интерфейса и один абстрактный класс (номенклатура должна быть согласована с преподавателем).
* В разработанных классах должны быть переопределены методы equals(), toString() и hashCode().
* Программа должна содержать как минимум один перечисляемый тип (enum).

# Лабораторная работа №4

Разработать модель согласно предметной области:   

*Но вряд ли мама была бы так спокойна, если бы поняла до конца, что именно сказал ей Малыш. Ведь подумать только, где жил Карлсон! Малыш встал из-за стола сытый, веселый и вполне довольный жизнью. Шишка на лбу уже не болела, во рту был изумительный вкус плюшек с корицей, через кухонное окно светило солнце, и мама выглядела такой милой в своем клетчатом переднике. Малыш подошел к ней, чмокнул ее полную руку и сказал: Затем Малыш пошел к себе в комнату и стал ждать Карлсона. Они должны были сегодня вместе отправиться на крышу, и, если бы Карлсон был только выдумкой, как уверяет Кристер, вряд ли Малыш смог бы туда попасть. "Я прилечу за тобой приблизительно часа в три, или в четыре, или в пять, но ни в коем случае не раньше шести", -- сказал ему Карлсон.*


Программа должна удовлетворять следующим требованиям:
* В программе должны быть реализованы 2 собственных класса исключений (checked и unchecked), а также обработка исключений этих классов.
* В программу необходимо добавить использование локальных, анонимных и вложенных классов (static и non-static).

# Лабораторная работа №5

Реализовать консольное приложение, которое реализует управление коллекцией объектов в интерактивном режиме. В коллекции необходимо хранить объекты класса City, описание которого приведено ниже.  

Разработанная программа должна удовлетворять следующим требованиям:
* Класс, коллекцией экземпляров которого управляет программа, должен реализовывать сортировку по умолчанию.
* Все требования к полям класса (указанные в виде комментариев) должны быть выполнены.
* Для хранения необходимо использовать коллекцию типа java.util.TreeMap
* При запуске приложения коллекция должна автоматически заполняться значениями из файла.
* Имя файла должно передаваться программе с помощью: переменная окружения.
* Данные должны храниться в файле в формате csv
* Чтение данных из файла необходимо реализовать с помощью класса java.io.BufferedInputStream
* Запись данных в файл необходимо реализовать с помощью класса java.io.BufferedWriter
* Все классы в программе должны быть задокументированы в формате javadoc.
* Программа должна корректно работать с неправильными данными (ошибки пользовательского ввода, отсутсвие прав доступа к файлу и т.п.).



# Лабораторная работа №6

Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.  

Необходимо выполнить следующие требования:
* Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
* Объекты между клиентом и сервером должны передаваться в сериализованном виде.
* Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по размеру
* Клиент должен корректно обрабатывать временную недоступность сервера.
* Обмен данными между клиентом и сервером должен осуществляться по протоколу TCP
* Для обмена данными на сервере необходимо использовать потоки ввода-вывода
* Для обмена данными на клиенте необходимо использовать сетевой канал
* Сетевые каналы должны использоваться в неблокирующем режиме.  

Обязанности серверного приложения:
* Работа с файлом, хранящим коллекцию.
* Управление коллекцией объектов.
* Назначение автоматически генерируемых полей объектов в коллекции.
* Ожидание подключений и запросов от клиента.
* Обработка полученных запросов (команд).
* Сохранение коллекции в файл при завершении работы приложения.
* Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).


# Лабораторная работа №7

Доработать программу из лабораторной работы №6 следующим образом:
1.	Организовать хранение коллекции в реляционной СУБД (PostgresQL). Убрать хранение коллекции в файле.
2.	Для генерации поля id использовать средства базы данных (sequence).
3.	Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
4.	Все команды получения данных должны работать с коллекцией в памяти, а не в БД
5.	Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
6.	Пароли при хранении хэшировать алгоритмом MD5
7.	Запретить выполнение команд не авторизованным пользователям.
8.	При хранении объектов сохранять информацию о пользователе, который создал этот объект.
9.	Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие им.
10.	Для идентификации пользователя отправлять логин и пароль с каждым запросом.


# Лабораторная работа №8

Доработать программу из лабораторной работы №7 следующим образом:
Заменить консольный клиент на клиент с графическим интерфейсом пользователя(GUI).  

В функционал клиента должно входить:
1.	Окно с авторизацией/регистрацией.
2.	Отображение текущего пользователя.
3.	Таблица, отображающая все объекты из коллекции
a.	Каждое поле объекта - отдельная колонка таблицы.
b.	Строки таблицы можно фильтровать/сортировать по значениям любой из колонок. Сортировку и фильтрацию значений столбцов реализовать с помощью Streams API.
4.	Поддержка всех команд из предыдущих лабораторных работ.
5.	Область, визуализирующую объекты коллекции  

a.	Объекты должны быть нарисованы с помощью графических примитивов с использованием Graphics, Canvas или аналогичных средств графической библиотеки.  
b.	При визуализации использовать данные о координатах и размерах объекта.  
c.	Объекты от разных пользователей должны быть нарисованы разными цветами.  
d.	При нажатии на объект должна выводиться информация об этом объекте.  
e.	При добавлении/удалении/изменении объекта, он должен автоматически появиться/исчезнуть/измениться  на области как владельца, так и всех других клиентов.  
f.	При отрисовке объекта должна воспроизводиться согласованная с преподавателем анимация.  
6.	Возможность редактирования отдельных полей любого из объектов (принадлежащего пользователю). Переход к редактированию объекта возможен из таблицы с общим списком объектов и из области с визуализацией объекта.  
7.	Возможность удаления выбранного объекта (даже если команды remove ранее не было).
